using System;
using System.Linq;
using System.Text;
namespace KozzionCore.Tools
{
	public class ToolsBinary
	{
		// Mask for casting a byte to an int, bit-by-bit (with
		// bitwise AND) with no special consideration for the sign bit.
		private static int     BITWISE_BYTE_TO_INT = 0x000000FF;

		private static char [] HEX_CHARS           = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

		public static byte xor(
			byte byte_0,
			byte byte_1)
		{
			return (byte) (byte_0 ^ byte_1);
		}

		public static byte xor(
			byte byte_0,
			byte byte_1,
			byte [] look_up_table)
		{
			return look_up_table[convert_to_int(byte_0, byte_1)];
		}



		public static byte [] xor(
			byte [] array_0,
			byte [] array_1)
		{
			byte [] result = new byte [array_0.Length];
			for (int index = 0; index < result.Length; index++)
			{
				result[index] = xor(array_0[index], array_1[index]);
			}
			return result;
		}

		public static byte convert_to_int(
			byte byte_0,
			byte byte_1)
		{
			return (byte) ((byte_0 & 0xFF) << 8 | (byte_1 & 0xFF));
		}

        /**
		 * Converts an array of bytes in to a String of characters to a byte array using the default (ASCII)code book
		 * 
		 * @param data
		 *            An array of bytes to convert to a String.
		 * @return A hexadecimal String representation of the data.
		 */
        public static byte[] RegularStringToByteArrayASCII(string regular_string)
        {
            return Encoding.ASCII.GetBytes(regular_string);
        }

        public static string ByteArrayToRegularString(byte[] bytes)
        {
            return Encoding.ASCII.GetString(bytes);
        }

        /**
       * Converts an array of bytes in to a String of characters to a byte array using the default code book
       * 
       * @param data
       *            An array of bytes to convert to a String.
       * @return A hexadecimal String representation of the data.
       */
        public static byte[] RegularStringToByteArray(string regular_string, Encoding encoding)
        {
            return encoding.GetBytes(regular_string); ;
        }

		/**
		 * Converts an array of bytes in to a String of hexadecimal characters (0 - F).
		 * 
		 * @param data
		 *            An array of bytes to convert to a String.
		 * @return A hexadecimal String representation of the data.
		 */

        public static byte[] HexStringToByteArray(string hex)
        {
            if (hex.Length % 2 != 0)
            {
                throw new Exception("Hex string must have even number of characters.");
            }

            return Enumerable.Range(0, hex.Length)
                             .Where(x => x % 2 == 0)
                             .Select(x => Convert.ToByte(hex.Substring(x, 2), 16))
                             .ToArray();
        }

        /**
         * Converts a hexadecimal String (such as one generated by the {@link #convertBytesToHexString(byte[])} method) into
         * an array of bytes.
         * 
         * @param hex
         *            The hexadecimal String to be converted into an array of bytes.
         * @return An array of bytes that.
         */
        public static byte[] convertHexStringToBytes(
        String hex)
        {
            if (hex.Length % 2 != 0)
            {
                throw new Exception("Hex string must have even number of characters.");
            }
            byte[] seed = new byte[hex.Length / 2];
            for (int i = 0; i < seed.Length; i++)
            {
                int index = i * 2;
                //seed[i] = (byte) int.Parse(hex.Substring(index, index + 2), 16); //TODO fix this
            }
            return seed;
        }

		public static String BytesArrayToHexString(
			byte [] data)
		{
			StringBuilder buffer = new StringBuilder(data.Length * 2);
			foreach (byte b in data)
			{
				buffer.Append(HEX_CHARS[(b >> 4) & 0x0F]);
				buffer.Append(HEX_CHARS[b & 0x0F]);
			}
			return buffer.ToString();
		}


	

		/**
		 * Take four bytes from the specified position in the specified
		 * block and convert them into a 32-bit int, using the big-endian
		 * convention.
		 * 
		 * @param bytes
		 *            The data to read from.
		 * @param offset
		 *            The position to start reading the 4-byte int from.
		 * @return The 32-bit integer represented by the four bytes.
		 */
		public static int convertBytesToInt(
			byte [] bytes,
			int offset)
		{
			return (BITWISE_BYTE_TO_INT & bytes[offset + 3]) | ((BITWISE_BYTE_TO_INT & bytes[offset + 2]) << 8)
				| ((BITWISE_BYTE_TO_INT & bytes[offset + 1]) << 16) | ((BITWISE_BYTE_TO_INT & bytes[offset]) << 24);
		}
    
		public static int convertBytesToInt(
			byte [] bytes)
		{
			return (BITWISE_BYTE_TO_INT & bytes[3]) | ((BITWISE_BYTE_TO_INT & bytes[2]) << 8)
				| ((BITWISE_BYTE_TO_INT & bytes[1]) << 16) | ((BITWISE_BYTE_TO_INT & bytes[0]) << 24);
		}

		/**
		 * Convert an array of bytes into an array of ints. 4 bytes from the
		 * input data map to a single int in the output data.
		 * 
		 * @param bytes
		 *            The data to read from.
		 * @return An array of 32-bit integers constructed from the data.
		 * @since 1.1
		 */
		public static int [] convertBytesToInts(
			byte [] bytes)
		{
			if (bytes.Length % 4 != 0)
			{
				throw new Exception("Number of input bytes must be a multiple of 4.");
			}
			int [] ints = new int [bytes.Length / 4];
			for (int i = 0; i < ints.Length; i++)
			{
				ints[i] = convertBytesToInt(bytes, i * 4);
			}
			return ints;
		}

		/**
		 * Utility method to convert an array of bytes into a long. Byte ordered is
		 * assumed to be big-endian.
		 * 
		 * @param bytes
		 *            The data to read from.
		 * @param offset
		 *            The position to start reading the 8-byte long from.
		 * @return The 64-bit integer represented by the eight bytes.
		 * @since 1.1
		 */
		public static long convertBytesToLong(
			byte [] bytes,
			int offset)
		{
			long value = 0;
			for (int i = offset; i < offset + 8; i++)
			{
				byte b = bytes[i];
				value <<= 8;
				value |= b;
			}
			return value;

		}

		public static byte [] convertIntToBytes(
			int value)
		{
			byte [] bytes = new byte [4];
			convert_int_to_bytes(value, bytes);
			return bytes;
		}

		public static void convert_int_to_bytes(
			int integer,
			byte [] byte_array)
		{
			byte_array[0] = (byte) (integer >> 24);
			byte_array[1] = (byte) (integer >> 16);
			byte_array[2] = (byte) (integer >> 8);
			byte_array[3] = (byte) integer;

		}

		// TODO add static charset for this
		public static byte [] convert_to_byte_array(
			String value)
		{
			//return value.getBytes();
			return null;
		}

		public static int [] convert_to_positive_ints(
			byte [] bytes)
		{
			int [] positive_ints = new int [bytes.Length];
			for (int index = 0; index < positive_ints.Length; index++)
			{
				positive_ints[index] = (bytes[index] + 256) % 256;
			}
			return positive_ints;
		}
	}
}
